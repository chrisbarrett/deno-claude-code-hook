# @chrisbarrett/claude-code-hook

[![JSR](https://jsr.io/badges/@chrisbarrett/claude-code-hook)](https://jsr.io/@chrisbarrett/claude-code-hook)

Type-safe Deno library for building [Claude Code](https://code.claude.com) hooks
with runtime validation. Using this lib you can write self-contained hook
scripts with LSP completions and editor squiggles to guide you.

For the full documentation, check the
[latest release on JSR](https://jsr.io/@chrisbarrett/claude-code-hook@latest).

## Quick Start

The example below will teach Claude Code to use the `say` command on macOS to
announce when it's compacting. The announcement is a bit terser if compaction
was user-initiated via `/compact`.

```typescript
#!/usr/bin/env -S deno run --allow-read --allow-run
import { preCompact } from "jsr:@chrisbarrett/claude-code-hook";
import $ from "jsr:@david/dax";

preCompact(async (input) => {
  const message = input.trigger === "auto"
    ? "Auto-compaction started"
    : "Compacting";

  await $`nohup -- say ${message}`;
});
```

Don't forget to `chmod +x`!

**Configure in `~/.claude/settings.json`:**

```json
{
  "hooks": {
    "PreCompact": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "/path/to/your/script"
          }
        ]
      }
    ]
  }
}
```

## Features

- **Type-safe** - Full TypeScript types for all hook inputs and outputs
- **Validated** - Zod schemas ensure runtime type safety
- **Zero config** - Handles all stdin/stdout/JSON serialization

## Prerequisites

Make sure you have Deno installed, then get scripting! Your
`~/.claude/settings.json` file is how you teach Claude Code to run your scripts
on hook events; see the
[Claude Code hooks documentation](https://code.claude.com/docs/en/hooks) to get
started.

## Permissions

Hooks require explicit Deno permissions. You'll need at least:

| Permission      | Purpose                                                       |
| --------------- | ------------------------------------------------------------- |
| `--allow-read`  | Read JSON sent by Claude Code over stdin                      |
| `--allow-env`   | Access environment variables for self-configuration           |
| `--allow-write` | Writing to files (e.g. with `persistEnvVar`), logging to disk |

<!-- prettier-ignore-start -->

> [!TIP]
> If you get sick of playing whack-a-mole with Deno permissions, the YOLO
> setting is `--allow-all`.

<!-- prettier-ignore-end -->

## Examples

These are contrived examples generated by Claude Code, but you get the idea. :)

For the full documentation, check the
[latest release on JSR](https://jsr.io/@chrisbarrett/claude-code-hook@latest).

### Load Project Context on Session Start

```typescript
import { sessionStart } from "jsr:@chrisbarrett/claude-code-hook";
import $ from "jsr:@david/dax";

sessionStart(async (input, ctx) => {
  ctx.logger.info("Calling Git to get context information");
  const branch = await $`git branch --show-current`.text();
  const commits = await $`git log -5 --oneline`.text();

  return {
    hookSpecificOutput: {
      hookEventName: "SessionStart",
      additionalContext: `
Branch: ${branch}

Recent commits:
${commits}
      `.trim(),
    },
  };
});
```

### Block Dangerous File Operations

```typescript
import { preToolUse } from "jsr:@chrisbarrett/claude-code-hook";

preToolUse(async (input) => {
  if (input.tool_name === "Write" || input.tool_name === "Edit") {
    if (input.tool_input.file_path.includes(".env")) {
      return {
        hookSpecificOutput: {
          hookEventName: "PreToolUse",
          shouldProceed: false,
          blockedMessage: "No secrets for you!",
        },
      };
    }
  }
});
```

### Set Session-Level Environment Variables

```typescript
import { sessionStart } from "jsr:@chrisbarrett/claude-code-hook";

sessionStart(async (input, ctx) => {
  await ctx.persistEnvVar("SOME_SESSION_VARIABLE", "hello from Session Start!");
});
```

Subsequent hooks in your session can then use
`Deno.env.get("SOME_SESSION_VARIABLE")` to retrieve that value.

## Hook Return Values

Most hooks return either `void` or an object with `hookSpecificOutput`. Let the
types guide you.

```typescript
// Void return (no output)
sessionStart(async (input, ctx) => {
  ctx.logger.info("Session started");
  // No return needed
});

// With output
sessionStart(async (input) => {
  return {
    hookSpecificOutput: {
      hookEventName: "SessionStart",
      additionalContext: "Your context here",
    },
  };
});

// Blocking (PreToolUse, UserPromptSubmit)
preToolUse(async (input) => {
  return {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      shouldProceed: false,
      blockedMessage: "Operation not allowed",
    },
  };
});

// Force continuation (Stop, SubagentStop)
stop(async (input) => {
  return {
    hookSpecificOutput: {
      hookEventName: "Stop",
      mustContinue: true,
      additionalContext: "Please continue with next steps",
    },
  };
});
```

## Type-safe Tool Call Inspections

Check the `type` of a tool to get type-safe access to its inputs.

```typescript
import { preToolUse } from "jsr:@chrisbarrett/claude-code-hook";

preToolUse(async (input) => {
  if (input.type === "Read") {
    const path = input.tool_input.file_path;
  } else if (input.type === "Edit") {
    const { file_path, old_string, new_string } = input.tool_input;
  }
});
```

A number of the built-in tools have types defined for their inputs; for
everything else you can fall back on `input.type === "Unknown"`; you might like
to use Zod schemas to validate such tools. ;)

## Claude Code Documentation

For comprehensive hook documentation, see the
[official Claude Code hooks guide](https://code.claude.com/docs/en/hooks).
